<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="overview_debugging" kind="page">
    <compoundname>overview_debugging</compoundname>
    <title>Debugging</title>
    <tableofcontents/>
    <briefdescription>
<para><linebreak/>
 Various classes, functions and macros are provided in wxWidgets to help you debug your application. </para>    </briefdescription>
    <detaileddescription>
<para><linebreak/>
 Various classes, functions and macros are provided in wxWidgets to help you debug your application.</para><para>Assertion macros allow you to insert various checks in your application which can be compiled out or disabled in release builds but are extremely useful while developing. Logging functions are also provided which are useful for inserting traces into your application code as well as debugging. Both assertions and debug logging are also used by wxWidgets itself so you may encounter them even if you don&apos;t use either of these features yourself.</para><para><simplesect kind="see"><para><ref refid="classwx_log" kindref="compound">wxLog</ref>, <ref refid="group__group__funcmacro__log" kindref="compound">Logging</ref>, <ref refid="group__group__funcmacro__debug" kindref="compound">Debugging macros</ref></para></simplesect>
</para><sect1 id="overview_debugging_1overview_debugging_config">
<title>Configuring Debug Support</title>
<para>Starting with wxWidgets 2.9.1 debugging features are always available by default (and not only in a special &quot;debug&quot; build of the library) and you need to predefine wxDEBUG_LEVEL symbol as 0 when building both the library and your application to remove them completely from the generated object code. However the debugging features are disabled by default when the application itself is built with <computeroutput>NDEBUG</computeroutput> defined (i.e. in &quot;release&quot; or &quot;production&quot; mode) so there is no need to do this, unless the resources of the system your application will be running on are unusually constrained (notice that when asserts are disabled their condition is not even evaluated so the only run-time cost is a single condition check and the extra space taken by the asserts in the code).</para><para>This automatic deactivation of debugging code is done by <ref refid="group__group__funcmacro__rtti_1ga967aafaa261481fe2d2e1cf599e3e003" kindref="member">wxIMPLEMENT_APP()</ref> macro so if you don&apos;t use you may need to explicitly call <ref refid="group__group__funcmacro__debug_1ga8db18cbe95b3b42c3017a8bf048b0839" kindref="member">wxDISABLE_DEBUG_SUPPORT()</ref> yourself.</para><para>Also notice that it is possible to build your own application with a different value of wxDEBUG_LEVEL than the one which was used for wxWidgets itself. E.g. you may be using an official binary version of the library which will have been compiled with default<programlisting><codeline><highlight class="normal">wxDEBUG_LEVEL<sp/>==<sp/>1<sp/></highlight></codeline>
</programlisting> but still predefine wxDEBUG_LEVEL as 0 for your own code.</para><para>On the other hand, if you do want to keep the asserts even in production builds, you will probably want to override the handling of assertion failures as the default behaviour which pops up a message box notifying the user about the problem is usually inappropriate. Use <ref refid="group__group__funcmacro__debug_1ga7a8443c97e45d2943f03769aaa787376" kindref="member">wxSetAssertHandler()</ref> to set up your own custom function which should be called instead of the standard assertion failure handler. Such function could log an appropriate message in the application log file or maybe notify the user about the problem in some more user-friendly way.</para></sect1>
<sect1 id="overview_debugging_1overview_debugging_dbgmacros">
<title>Assertion Macros</title>
<para><ref refid="group__group__funcmacro__debug_1ga204cc264ee560b67e6c6467ba8ffee5f" kindref="member">wxASSERT()</ref>, <ref refid="group__group__funcmacro__debug_1gaa5b456751cd8c71e9a787fba16ecbd68" kindref="member">wxFAIL()</ref>, <ref refid="group__group__funcmacro__debug_1gacce4d688e56d4de1bbef692e7df2e3e3" kindref="member">wxCHECK()</ref> as well as their other variants (see <ref refid="group__group__funcmacro__debug" kindref="compound">Debugging macros</ref>) are similar to the standard assert() macro but are more flexible and powerful. The first of them is equivalent to assert() itself, i.e. it simply checks a condition and does nothing if it is true. The second one is equivalent to checking an always false condition and is supposed to be used for code paths which are supposed to be inaccessible (e.g. <computeroutput>default</computeroutput> branch of a <computeroutput>switch</computeroutput> statement which should never be executed). Finally, the <ref refid="group__group__funcmacro__debug_1gacce4d688e56d4de1bbef692e7df2e3e3" kindref="member">wxCHECK()</ref> family of macros verifies the condition just as <ref refid="group__group__funcmacro__debug_1ga204cc264ee560b67e6c6467ba8ffee5f" kindref="member">wxASSERT()</ref> does and performs some action such returning from the function if it fails <ndash/> thus, it is useful for checking the functions preconditions.</para><para>All of the above functions exist in <computeroutput>_MSG</computeroutput> variants which allow you to provide a custom message which will be shown (or, more generally, passed to the assert handler) if the assertion fails, in addition to the usual file and line number information and the condition itself.</para><para>Example of using an assertion macro: <programlisting><codeline><highlight class="normal">void<sp/>GetTheAnswer(int<sp/>*p)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>wxCHECK_RET(<sp/>p,<sp/>&quot;pointer<sp/>can&apos;t<sp/>be<sp/>NULL<sp/>in<sp/>GetTheAnswer()&quot;<sp/>);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>*p<sp/>=<sp/>42;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para><para>If the condition is false, i.e. <computeroutput>p</computeroutput> is NULL, the assertion handler is called and, in any case (even when wxDEBUG_LEVEL is 0), the function returns without dereferencing the NULL pointer on the next line thus avoiding a crash.</para><para>The default assertion handler behaviour depends on whether the application using wxWidgets was compiled in release build (with <computeroutput>NDEBUG</computeroutput> defined) or debug one (without) but may be changed in either case as explained above. If it wasn&apos;t changed, then nothing will happen in the release build and a message box showing the information about the assert as well as allowing to stop the program, ignore future asserts or break into the debugger is shown. On the platforms where <ref refid="classwx_stack_walker" kindref="compound">wxStackWalker</ref> is supported the message box will also show the stack trace at the moment when the assert failed often allowing you to diagnose the problem without using the debugger at all. You can see an example of such message box in the <ref refid="page_samples_1page_samples_except" kindref="member">Exception Sample</ref>.</para></sect1>
<sect1 id="overview_debugging_1overview_debugging_logging">
<title>Logging Functions</title>
<para>You can use the wxLogDebug and wxLogTrace functions to output debugging information in debug mode; it will do nothing for non-debugging code. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
