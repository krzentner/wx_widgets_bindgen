<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="overview_changes_since28" kind="page">
    <compoundname>overview_changes_since28</compoundname>
    <title>Changes Since wxWidgets 2.8</title>
    <briefdescription>
<para><linebreak/>
 This topic describes backwards-incompatible changes in wxWidgets 3.0 compared to the last stable release and is very important to read if you are updating from the 2.8 or an older version. </para>    </briefdescription>
    <detaileddescription>
<para><linebreak/>
 This topic describes backwards-incompatible changes in wxWidgets 3.0 compared to the last stable release and is very important to read if you are updating from the 2.8 or an older version.</para><para>And even if you hadn&apos;t used any previous version of wxWidgets and are starting directly with 3.0, it can still be useful to have at least a quick look at it just to know that some of the older examples and tutorials may not be applicable any more to wxWidgets 3.0.</para><para>The incompatible changes can be grouped into the following categories:</para><para><itemizedlist>
<listitem><para><ref refid="overview_changes_since28_1overview_changes_unicode" kindref="member">Unicode-related Changes</ref> </para></listitem>
<listitem><para><ref refid="overview_changes_since28_1overview_changes_other" kindref="member">Miscellaneous Other Changes</ref></para></listitem>
</itemizedlist>
<hruler/>
</para><sect1 id="overview_changes_since28_1overview_changes_unicode">
<title>Unicode-related Changes</title>
<para>If you used Unicode build of wxWidgets 2.8 or previous version, please read <ref refid="overview_unicode" kindref="compound">Unicode Support in wxWidgets</ref> for the details about how the API changed in 3.0 as a lot of the information which was correct before doesn&apos;t apply any longer.</para><para>For example, the notorious (due to the confusion they created) macros <computeroutput><ref refid="group__group__funcmacro__string_1ga437ea6ba615b75dac8603e96ec864160" kindref="member">wxT()</ref></computeroutput> and <computeroutput><ref refid="group__group__funcmacro__string_1ga7dfc2888539861afe6c4337ef315472b" kindref="member">_T()</ref></computeroutput> are not needed at all any longer. Basically, you can remove them from any code which used them. On the other hand, there is no particular harm in leaving them neither as the code will still compile and work correctly <ndash/> you only need to remove them if you think that your code looks tidier without them. You also don&apos;t need to use <computeroutput>wxChar</computeroutput> any longer but can directly use the standard <computeroutput>wchar_t</computeroutput> type even if, again, <computeroutput>wxChar</computeroutput> continues to work.</para><para>The most serious backwards-incompatible change is related to the change of return type of <ref refid="classwx_string_1a5db49c775c09e77fe0acde2a928bbf8f" kindref="member">wxString::c_str()</ref> method: it returns a special proxy object instead of a simple <computeroutput>char*</computeroutput> or <computeroutput>wchar_t*</computeroutput> now. Because of this, you cannot pass its result to any standard vararg functions such as <computeroutput>printf()</computeroutput> any more as described in <ref refid="overview_unicode_1overview_unicode_compilation_errors" kindref="member">Unicode-Related Compilation Errors</ref>. All wxWidgets functions, such as wxPrintf(), <ref refid="group__group__funcmacro__log_1ga249358701f3c2d410088ddf7a61d8564" kindref="member">wxLogMessage()</ref> &amp;c still work with it, but passing it to <computeroutput>printf()</computeroutput> will now result in a crash. It is strongly advised to recompile your code with a compiler warning about passing non-POD objects to vararg functions, such as g++.</para><para>The change of the type of <ref refid="classwx_string_1a5db49c775c09e77fe0acde2a928bbf8f" kindref="member">wxString::c_str()</ref> can also result in compilation errors when passing its result to a function overloaded to take both narrow and wide strings and in this case you must select the version which you really want to use, e.g.: <programlisting><codeline><highlight class="normal">void<sp/>OpenLogFile(const<sp/>char<sp/>*filename);</highlight></codeline>
<codeline><highlight class="normal">void<sp/>OpenLogFile(const<sp/>wchar_t<sp/>*filename);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">wxString<sp/>s;</highlight></codeline>
<codeline><highlight class="normal">OpenLogFile(s);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>ERROR:<sp/>ambiguity</highlight></codeline>
<codeline><highlight class="normal">OpenLogFile(s.c_str());<sp/><sp/><sp/><sp/><sp/>//<sp/>ERROR:<sp/>ambiguity</highlight></codeline>
<codeline><highlight class="normal">OpenLogFile(s.wx_str());<sp/><sp/><sp/><sp/>//<sp/>OK:<sp/>function<sp/>called<sp/>depends<sp/>on<sp/>the<sp/>build</highlight></codeline>
<codeline><highlight class="normal">OpenLogFile(s.mb_str());<sp/><sp/><sp/><sp/>//<sp/>OK:<sp/>always<sp/>calls<sp/>narrow<sp/>string<sp/>overload</highlight></codeline>
<codeline><highlight class="normal">OpenLogFile(s.wc_str());<sp/><sp/><sp/><sp/>//<sp/>OK:<sp/>always<sp/>calls<sp/>wide<sp/>string<sp/>overload</highlight></codeline>
</programlisting> A common example of such problem arises with <computeroutput>std::fstream</computeroutput> class constructor in Microsoft Visual C++ standard library implementation. In addition to a constructor from <computeroutput>const</computeroutput> <computeroutput>char</computeroutput> * which this class must have, it also provides a constructor taking a wide character file name. Because of this, code like the following <programlisting><codeline><highlight class="normal">#include<sp/>&lt;fstream&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>MyFunc(const<sp/>wxString&amp;<sp/>filename)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::ifstream<sp/>ifs(filename.c_str());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> does not compile when using Microsoft Visual C++ and needs to be changed to use mb_str() (which will not work for file names containing Unicode characters, consider using wxWidgets classes and functions to work with such file names as they are not supported by standard C++ library).</para><para>The other class of incompatible changes is due to modifying some virtual methods to use <computeroutput><ref refid="classwx_string" kindref="compound">wxString</ref></computeroutput> parameters instead of <computeroutput>const</computeroutput> <computeroutput>wxChar*</computeroutput> ones to make them accept both narrow and wide strings. This is not a problem if you simply call these functions but you need to change the signature of the derived class versions if you override them as otherwise they wouldn&apos;t be called any more. Again, the best way to ensure that this problem doesn&apos;t arise is to rebuild your code using a compiler which warns about function signature mismatch (you can use <computeroutput>-Woverloaded-virtual</computeroutput> g++ option).</para><para>Finally, a few structure fields, notable <computeroutput><ref refid="structwx_cmd_line_entry_desc_1a1fa5b1fb90ff3051a011a6ce10261796" kindref="member">wxCmdLineEntryDesc::shortName</ref></computeroutput>, <computeroutput>longName</computeroutput> and <computeroutput>description</computeroutput> fields have been changed to be of type <computeroutput>const</computeroutput> <computeroutput>char*</computeroutput> instead of <computeroutput>const</computeroutput> <computeroutput>wxChar*</computeroutput> so you will need to remove <computeroutput><ref refid="group__group__funcmacro__string_1ga437ea6ba615b75dac8603e96ec864160" kindref="member">wxT()</ref></computeroutput> or <computeroutput><ref refid="group__group__funcmacro__string_1ga7dfc2888539861afe6c4337ef315472b" kindref="member">_T()</ref></computeroutput> if you used it with their initializers.</para></sect1>
<sect1 id="overview_changes_since28_1overview_changes_other">
<title>Miscellaneous Other Changes</title>
<para><itemizedlist>
<listitem><para>Default location of <ref refid="classwx_file_config" kindref="compound">wxFileConfig</ref> files has changed under Windows, you will need to update your code if you access these files directly.</para></listitem><listitem><para><ref refid="classwx_window_1a0c186513884fb2020c6af3c62f0913d2" kindref="member">wxWindow::IsEnabled()</ref> now returns false if a window parent (and not necessarily the window itself) is disabled, new function IsThisEnabled() with the same behaviour as old IsEnabled() was added.</para></listitem><listitem><para>Generating <ref refid="classwx_navigation_key_event" kindref="compound">wxNavigationKeyEvent</ref> events doesn&apos;t work any more under wxGTK (and other platforms in the future), use <ref refid="classwx_window_1a86904f6785df4af6036b33383490a805" kindref="member">wxWindow::Navigate()</ref> or NavigateIn() instead.</para></listitem><listitem><para>Sizers distribute only the extra space between the stretchable items according to their proportions and not all available space. We believe the new behaviour corresponds better to user expectations but if you did rely on the old behaviour you will have to update your code to set the minimal sizes of the sizer items to be in the same proportion as the items proportions to return to the old behaviour.</para></listitem><listitem><para><ref refid="classwx_window_1a15c678314cfc1d807196bc298b713ed3" kindref="member">wxWindow::Freeze</ref>/Thaw() are not virtual any more, if you overrode them in your code you need to override DoFreeze/Thaw() instead now.</para></listitem><listitem><para><ref refid="classwx_calendar_ctrl" kindref="compound">wxCalendarCtrl</ref> has native implementation in wxGTK, but it has less features than the generic one. The native implementation is used by default, but you can still use wxGenericCalendarCtrl instead of <ref refid="classwx_calendar_ctrl" kindref="compound">wxCalendarCtrl</ref> in your code if you need the extra features.</para></listitem><listitem><para>wxDocument::FileHistoryLoad() and <ref refid="classwx_file_history_1a2537201495686a3a6a26701e158ecfb3" kindref="member">wxFileHistory::Load()</ref> now take const reference to <ref refid="classwx_config_base" kindref="compound">wxConfigBase</ref> argument and not just a reference, please update your code if you overrode these functions and change the functions in the derived classes to use const reference as well.</para></listitem><listitem><para>Calling wxConfig::Write() with an enum value will fail to compile because wxConfig now tries to convert all unknown types to <ref refid="classwx_string" kindref="compound">wxString</ref> automatically using <ref refid="group__group__funcmacro__misc_1ga0adf8026ea8ed126420a2e7ef9edc678" kindref="member">wxToString()</ref> function.</para><para>The simplest solution is to cast the enum value to int, e.g. <programlisting><codeline><highlight class="normal">enum<sp/>Colour<sp/>{<sp/>Red,<sp/>Green,<sp/>Blue<sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">wxConfig<sp/>conf;</highlight></codeline>
<codeline><highlight class="normal">conf.Write(&quot;MyFavouriteColour&quot;,<sp/>Red);<sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>ERROR:<sp/>no<sp/>match</highlight></codeline>
<codeline><highlight class="normal">conf.Write(&quot;MyFavouriteColour&quot;,<sp/>int(Red));<sp/><sp/>//<sp/>OK</highlight></codeline>
</programlisting></para><para>Another possibility which exists now is to provide an overload of <ref refid="group__group__funcmacro__misc_1ga0adf8026ea8ed126420a2e7ef9edc678" kindref="member">wxToString()</ref> (and <ref refid="group__group__funcmacro__misc_1ga598ae7504c6436af325490b41f4b5e90" kindref="member">wxFromString()</ref>) for your own type, e.g.</para></listitem></itemizedlist>
</para><para><programlisting><codeline><highlight class="normal">wxString<sp/>wxToString(Colour<sp/>col)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>col<sp/>==<sp/>Red<sp/>?<sp/>&quot;R&quot;<sp/>:<sp/>col<sp/>==<sp/>Green<sp/>?<sp/>&quot;G&quot;<sp/>:<sp/>&quot;B&quot;;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">bool<sp/>wxFromString(const<sp/>wxString&amp;<sp/>s,<sp/>Colour*<sp/>col)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(<sp/>s.length()<sp/>!=<sp/>1<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>switch<sp/>(<sp/>s[0].GetValue()<sp/>)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;R&apos;:<sp/>*col<sp/>=<sp/>Red;<sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;G&apos;:<sp/>*col<sp/>=<sp/>Green;<sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>case<sp/>&apos;B&apos;:<sp/>*col<sp/>=<sp/>Blue;<sp/>return<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>false;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Of course, this will change the format of the wxConfig output which may be undesirable.</para><para><itemizedlist>
<listitem><para>wxTE_AUTO_SCROLL style is deprecated as it&apos;s always on by default anyhow in the ports which support it so you should simply remove any mentions of it from your code.</para></listitem><listitem><para>If you use <ref refid="classwx_scrolled_1a117dc8edabb3e1250199eab089e4fa5b" kindref="member">wxScrolled&lt;T&gt;::SetTargetWindow()</ref> you must override <ref refid="classwx_scrolled_1a81800886d1d5f094caeee683e707de12" kindref="member">wxScrolled&lt;T&gt;::GetSizeAvailableForScrollTarget()</ref> method to compute the size available for the scroll target as function of the main window size, please see the documentation of this method for more details.</para></listitem><listitem><para>Signature of <ref refid="classwx_data_view_custom_renderer_1a36d6d5c64097bb48f67a712ddb7f97bf" kindref="member">wxDataViewCustomRenderer::StartDrag()</ref> virtual method changed. You will need to change it in your derived renderer class too if you override it.</para></listitem><listitem><para><ref refid="classwx_data_view_custom_renderer_1a242d0992df73be6830e66d74b211974d" kindref="member">wxDataViewCustomRenderer::Activate()</ref> and <ref refid="classwx_data_view_custom_renderer_1ab7fe7693a94fee896eb0b60b843cd474" kindref="member">wxDataViewCustomRenderer::LeftClick()</ref> were replaced with the new <ref refid="classwx_data_view_custom_renderer_1a76e85467c89adae6612236d803a552fc" kindref="member">wxDataViewCustomRenderer::ActivateCell()</ref> method. You will need to change it in your derived renderer class accordingly. </para></listitem></itemizedlist>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
